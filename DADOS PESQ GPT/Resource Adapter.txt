# core/symbiotic_core/resource_adapter.py
"""
Resource Adapter layer for VIREON – allows the optimisation/guard module to start
with Warp integration (default) while remaining fully pluggable for future
providers (OpenAI, local LLMs, etc.).

Design goals
------------
• Small + self‑contained.  
• No third‑party deps beyond stdlib + `requests` (used by default WarpAdapter).  
• Clear abstraction: *quote* (estimate cost) and *execute* (perform request).  
• Registry pattern so new adapters can be discovered dynamically with almost
  zero friction.  
• Helpful doc‑strings + TODOs marking expansion points.

Usage snippet (inside optimiser/guard logic)  
```python
from resource_adapter import get_adapter

adapter = get_adapter("warp")   # or "openai", "local"
cost_est = adapter.quote(request)
if cost_est.too_high():
    # run dry‑run / cache lookup first
response = adapter.execute(request)
```
"""

from __future__ import annotations

import abc
import hashlib
import json
import os
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict, Optional, Type

import requests  # lightweight, ok to depend on

###############################################################################
# Core data models – deliberately minimal
###############################################################################

@dataclass
class Request:
    """Generic wrapper for a task/operation we want to run via some provider."""

    payload: Dict[str, Any]
    metadata: Dict[str, Any] = None  # free‑form – user, timestamps, etc.

    def fingerprint(self) -> str:
        """Stable hash – handy for cache / redundancy checks."""
        raw = json.dumps(self.payload, sort_keys=True) + (json.dumps(self.metadata, sort_keys=True) if self.metadata else "")
        return hashlib.sha256(raw.encode()).hexdigest()


@dataclass
class Response:
    """Standardised successful response wrapper."""

    data: Dict[str, Any]
    cost: float  # in $ or generic units
    provider: str
    timestamp: datetime = datetime.utcnow()


@dataclass
class Cost:
    """Estimation object used by `quote`."""

    amount: float  # dollars or tokens or tasks – adapter decides
    unit: str      # "USD", "tokens", "warp_tasks", etc.

    def too_high(self, threshold: float = 1.0) -> bool:  # default $1
        return self.amount >= threshold

###############################################################################
# Abstract adapter API
###############################################################################

class ResourceAdapter(abc.ABC):
    """All provider adapters must inherit from this base class."""

    id: str  # short identifier, eg. "warp", "openai"

    # --- lifecycle ---------------------------------------------------------

    def __init__(self, **kwargs):
        self.config = kwargs

    # --- required behaviours ----------------------------------------------

    @abc.abstractmethod
    def quote(self, request: Request) -> Cost:
        """Return *estimated* cost for the request (cheap / offline)."""

    @abc.abstractmethod
    def execute(self, request: Request) -> Response:
        """Actually performs the operation via remote/local engine."""

###############################################################################
# Concrete adapter: Warp CLI / API
###############################################################################

class WarpAdapter(ResourceAdapter):
    """Default adapter talking to Warp Agent REST or CLI.

    NOTE: minimal stub – fill `WARP_API_URL` env var or pass `api_url`.
    """

    id = "warp"

    def __init__(self, api_url: Optional[str] = None, token: Optional[str] = None, **kw):
        super().__init__(api_url=api_url, token=token, **kw)
        self.api_url = api_url or os.getenv("WARP_API_URL", "http://localhost:8001")
        self.token = token or os.getenv("WARP_TOKEN")
        if not self.token:
            raise RuntimeError("WarpAdapter needs an auth token – set WARP_TOKEN env var")

    # Simplistic heuristic – 1 task per call, price $0.01 (example) --------
    def quote(self, request: Request) -> Cost:
        return Cost(amount=0.01, unit="USD")  # TODO: refine with /quote endpoint when available

    def execute(self, request: Request) -> Response:
        headers = {"Authorization": f"Bearer {self.token}", "Content-Type": "application/json"}
        # Here we fire a generic call – adjust to real Warp API path
        resp = requests.post(f"{self.api_url}/agent/execute", headers=headers, json=request.payload, timeout=60)
        resp.raise_for_status()
        data = resp.json()
        # cost could come from headers or body – using fixed for demo
        return Response(data=data, cost=0.01, provider=self.id)

###############################################################################
# Registry / factory helpers
###############################################################################

_ADAPTERS: Dict[str, Type[ResourceAdapter]] = {
    WarpAdapter.id: WarpAdapter,
    # future: "openai": OpenAIAdapter,
    # future: "local": LocalAdapter,
}


def register_adapter(adapter_cls: Type[ResourceAdapter]):
    if adapter_cls.id in _ADAPTERS:
        raise KeyError(f"Adapter id '{adapter_cls.id}' already registered")
    _ADAPTERS[adapter_cls.id] = adapter_cls


def get_adapter(adapter_id: str, **kwargs) -> ResourceAdapter:
    """Factory – returns an *instance* of the requested adapter."""
    try:
        cls = _ADAPTERS[adapter_id]
        return cls(**kwargs)
    except KeyError as exc:
        raise ValueError(f"Unknown adapter '{adapter_id}'. Available: {list(_ADAPTERS)}") from exc

###############################################################################
# Quick CLI demo (optional)
###############################################################################

if __name__ == "__main__":
    import argparse, pprint, sys

    parser = argparse.ArgumentParser(description="Quick test for ResourceAdapter")
    parser.add_argument("adapter", choices=list(_ADAPTERS), help="Which adapter to test")
    parser.add_argument("payload", help="JSON payload string to send")
    args = parser.parse_args()

    adapter = get_adapter(args.adapter)
    req = Request(payload=json.loads(args.payload))

    print("Quote =>", adapter.quote(req))
    try:
        resp = adapter.execute(req)
        pprint.pprint(resp.__dict__)
    except Exception as e:
        print("ERROR:", e, file=sys.stderr)
        sys.exit(1)
